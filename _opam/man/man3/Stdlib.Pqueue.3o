.TH "Stdlib.Pqueue" 3 2025-11-21 OCamldoc "OCaml library"
.SH NAME
Stdlib.Pqueue \- no description
.SH Module
Module   Stdlib.Pqueue
.SH Documentation
.sp
Module
.BI "Pqueue"
 : 
.B (module Stdlib__Pqueue)

.sp

.sp

.sp
.sp
.I module type OrderedType = 
.B sig end

.sp
Input signature of the functors 
.ft B
Pqueue\&.MakeMin
.ft R
and 
.ft B
Pqueue\&.MakeMax
.ft R
\&.

.sp
.I module type Min = 
.B sig end

.sp
Output signature of the functor 
.ft B
Pqueue\&.MakeMin
.ft R
\&.

.sp
.I module MakeMin : 
.B (E : OrderedType) -> sig end

.sp
Functor building an implementation of the min\-priority queue
structure given a totally ordered type for elements\&.

.sp
.I module type Max = 
.B sig end

.sp
Output signature of the functor 
.ft B
Pqueue\&.MakeMax
.ft R
\&.

.sp
.I module MakeMax : 
.B (E : OrderedType) -> sig end

.sp
Functor building an implementation of the max\-priority queue
structure given a totally ordered type for elements\&.

.sp

.PP
.SS Polymorphic priority queues
.sp
The following, more complex functors create polymorphic queues of
type 
.ft B
\&'a t
.ft R
, just like other polymorphic containers (lists,
arrays\&.\&.\&.)\&. They require a notion of "polymorphic elements" 
.ft B
\&'a
.br
\&    elt
.ft R
that can be compared without depending on the values of 
.ft B
\&'a
.ft R
\&.
.sp
One usage scenario is when the user wants to pass priorities
separately from the value stored in the queue\&. This is done by
using pairs 
.ft B
priority * \&'a
.ft R
as elements\&.
.EX
.ft B
.br
\&      module Prio : OrderedType = \&.\&.\&.
.br
\&
.br
\&      module PrioQueue = Pqueue\&.MakeMinPoly(struct
.br
\&        type \&'a t = Prio\&.t * \&'a
.br
\&        let compare (p1, _) (p2, _) = Prio\&.compare p1 p2
.br
\&      end)
.br
\&
.br
\&      (* for example, we now have: *)
.br
\&      PrioQueue\&.add: \&'a PrioQueue\&.t \-> Prio\&.t * \&'a \-> unit
.br
\&      PrioQueue\&.min_elt: \&'a PrioQueue\&.t \-> (Prio\&.t * \&'a) option
.br
\&    
.ft R
.EE
.PP
.I module type OrderedPolyType = 
.B sig end

.sp
Input signature of the functors 
.ft B
Pqueue\&.MakeMinPoly
.ft R
and 
.ft B
Pqueue\&.MakeMaxPoly
.ft R
\&.

.sp
.I module type MinPoly = 
.B sig end

.sp
Output signature of the functor 
.ft B
Pqueue\&.MakeMinPoly
.ft R
\&.

.sp
.I module MakeMinPoly : 
.B (E : OrderedPolyType) -> sig end

.sp
Functor building an implementation of min\-priority queues
given a totally ordered type for the elements\&.

.sp
.I module type MaxPoly = 
.B sig end

.sp
Output signature of the functor 
.ft B
Pqueue\&.MakeMaxPoly
.ft R
\&.

.sp
.I module MakeMaxPoly : 
.B (E : OrderedPolyType) -> sig end

.sp
Functor building an implementation of max\-priority queues
given a totally ordered type for the elements\&.

.sp
